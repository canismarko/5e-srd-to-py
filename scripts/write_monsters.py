import os
import re
from pathlib import Path
import shelve
import textwrap
import ast
import astunparse


inf = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "local_data", "monsters.shlf")
outf = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "output_files", "monsters.py")
outf_unittest = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "output_files", "test_monsters.py")

header = """\"\"\"
monsters.py

A collection of monsters from D&D 5e's SRD

Part of this file was autogenerated by https://github.com/stravajiaxen/5e-srd-to-py
\"\"\"

class Monster:
    pass
    
class Ability:
    
    def __init__(self, num):
        pass

"""

individual_class = \
'''

class {classname}(Monster):
    """
{description}
    """
    name = "{name}"
    description = "{size} {type}, {alignment}"
    challenge_rating = {challenge_rating}
    armor_class = {armor_class}
    skills = "{skills}"
    senses = "{senses}"
    languages = "{languages}"
    strength = Ability({strength})
    dexterity = Ability({dexterity})
    constitution = Ability({constitution})
    intelligence = Ability({intelligence})
    wisdom = Ability({wisdom})
    charisma = Ability({charisma})
    speed = {speed_walk}
    swim_speed = {speed_swim}
    fly_speed = {speed_fly}
    climb_speed = {speed_climb}
    hp_max = {hit_points}
    hit_dice = "{hit_dice}"
    spells = {spells}
'''

unittest_template = \
'''from unittest import TestCase

from dungeonsheets import monsters


class AutoGeneratedMonsters(TestCase):

    initializable_classes = [
        {initializable_classes}
    ]
    
    def test_createable(self):
        for InitializableClass in self.initializable_classes:
            # All classes should be initializable, so just try to
            # create each monster
            _ = InitializableClass()

'''

all_monster_classes = []


def format_description(text):
    """Returns a string with the right indentation and formation for an
    attack description.

    """
    paragraphs = text.split("\n")
    paragraphs = ["\n  ".join(textwrap.wrap(par)) for par in paragraphs]
    return "\n      \n  ".join(paragraphs)


def get_spells(monster_data):
    """Returns a string list of spells the monster can cast."""
    spells = []
    for ability in monster_data.get("special_abilities", []):
        if ability['name'] == "Spellcasting":
            spells = ['"%s"' % spell["name"].lower() for spell in ability["spellcasting"]["spells"]]
    return "[" + ", ".join(spells) + "]"


def get_attacks(monster_data):
    """
    Returns a string list of attacks for the monster

    :param monster_data:
    :return:
    """
    outstr = ""
    things = []
    for ability in monster_data.get("special_abilities", []):
        things.append(ability["name"] + ".\n  " + format_description(ability["desc"]))
    for attack in monster_data.get("actions", []):
        things.append(attack["name"] + ".\n  " + format_description(attack["desc"]))
    if things:
        outstr = "" + "\n".join(things)
    return textwrap.indent(outstr, "    ")


def get_skills(monster_data):
    """
    Returns a string list of skills for the monster

    :param monster_data:
    :return:
    """
    # TODO: Also save saving throws
    outstr = ""
    profs = []
    for proficiency in monster_data.get("proficiencies", []):
        if "skill" in proficiency['proficiency']['index']:
            value = proficiency["value"]
            name = proficiency['proficiency']["index"].split("skill-")[1].capitalize()
            prof = f"{name} +{value}"
            profs.append(prof)
    if len(profs) > 0:
        outstr = ", ".join(profs)
    return outstr
    # TODO: Write me!


def get_senses(monster_data):
    """
    Returns a string list of senses for the monster

    :param monster_data:
    :return:
    """
    if not monster_data.get("senses"):
        return ""

    senses = []
    for sense, val in monster_data.get("senses", []).items():
        sense_word = " ".join([word.capitalize() for word in sense.split("_")])
        if type(val) == int:
            sense_val = f"{val}"
        else:
            sense_val = val
        # sense_val = f"+ {val}" if ((type(val) != int) or ("ft" not in val)) else val
        senses.append(sense_word + " " + sense_val)
    return ", ".join(senses)
    # TODO: Write me!


def monster_classname(name):
    classname = "".join(name.split())
    replacements = [",", "/", "(", ")", "-", "'"]
    for r in replacements:
        classname = classname.replace(r, "")
    return classname


def get_monster_string(monster_data):
    data = monster_data
    data["classname"] = monster_classname(data["name"])
    all_monster_classes.append(data["classname"])
    data["description"] = get_attacks(monster_data)
    data["skills"] = get_skills(monster_data)
    data["speed_walk"] = (monster_data["speed"].get("walk", "0").split()[0])
    data["speed_swim"] = (monster_data["speed"].get("swim", "0").split()[0])
    data["speed_fly"] = (monster_data["speed"].get("fly", "0").split()[0])
    data["speed_climb"] = (monster_data["speed"].get("climb", "0").split()[0])
    data["senses"] = get_senses(monster_data)
    data["spells"] = get_spells(monster_data)
    ret = (individual_class.format(**data))
    return ret


def get_existing_ast():
    """Load some existing monster definitions as an Abstract Syntax Tree"""
    extra_dir = Path('~/src/dungeon-sheets/dungeonsheets/monsters').expanduser()
    extra_files = [extra_dir / f"monsters_{l}.py" for l in ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')]
    # Open each file and load the AST
    monsters = {}
    for path in extra_files:
        with open(path, mode='r') as fp:
            tree = ast.parse(fp.read())
            for item in tree.body:
                if isinstance(item, ast.ClassDef):
                    monsters[item.name] = item
    return monsters


def unparse_monster_ast(monster_ast):
    # Handle the docstring
    docstring = monster_ast.body[0].value.s
    pycode = astunparse.unparse(monster_ast)
    # Fix the docstring
    pycode = re.sub('^    "(.*)"$',
                    r'    """\1"""',
                    pycode, flags=re.M)
    pycode = re.sub("^    '(.*)'$",
                    r'    """\1"""',
                    pycode, flags=re.M)
    pycode = pycode.replace(r'\n', '\n')
    return pycode


def write_monsters():
    # Load existing monsters as an AST
    monsters_ast = get_existing_ast()
    # Create new monsters as AST and overwrite existing class defs
    with shelve.open(inf, 'r') as db:
        outstr = header
        for monster in db["data"]:
            monster_string = get_monster_string(monster)
            monster_ast = ast.parse(monster_string).body[0]
            classname = monster_classname(monster["name"])
            monsters_ast[classname] = monster_ast
    with open(outf, 'w') as f:
        f.write(header)
        f.write("\n\n")
        # Convert AST's back into python code
        for classname, monster_ast in sorted(monsters_ast.items()):
            f.write(unparse_monster_ast(monster_ast))


def write_monsters_test():
    if not all_monster_classes:
        raise ValueError("Must first run write_monsters to get the classes")
    initializable_classes = ",\n        ".join([f"monsters.{this_class}" for this_class in all_monster_classes])
    outstr = unittest_template.format(initializable_classes=initializable_classes)
    with open(outf_unittest, 'w') as f:
        f.write(outstr)


if __name__ == '__main__':
    write_monsters()
    write_monsters_test()
