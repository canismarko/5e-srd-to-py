import os
import shelve
import textwrap

inf = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "local_data", "monsters.shlf")
outf = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "output_files", "monsters.py")
outf_unittest = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "output_files", "test_monsters.py")

header = """\"\"\"
monsters.py

A collection of monsters from D&D 5e's SRD

Part of this file was autogenerated by https://github.com/stravajiaxen/5e-srd-to-py
\"\"\"

class Monster:
    pass
    
class Ability:
    
    def __init__(self, num):
        pass

"""

individual_class = \
'''

class {classname}(Monster):
    """
{description}
    """
    name = "{name}"
    description = "{size} {type}, {alignment}"
    challenge_rating = {challenge_rating}
    armor_class = {armor_class}
    skills = "{skills}"
    senses = "{senses}"
    languages = "{languages}"
    strength = Ability({strength})
    dexterity = Ability({dexterity})
    constitution = Ability({constitution})
    intelligence = Ability({intelligence})
    wisdom = Ability({wisdom})
    charisma = Ability({charisma})
    speed = {speed_walk}
    swim_speed = {speed_swim}
    fly_speed = {speed_fly}
    climb_speed = {speed_climb}
    hp_max = {hit_points}
    hit_dice = "{hit_dice}"
    spells = {spells}
'''

unittest_template = \
'''from unittest import TestCase

from dungeonsheets import monsters


class AutoGeneratedMonsters(TestCase):

    initializable_classes = [
        {initializable_classes}
    ]
    
    def test_createable(self):
        for InitializableClass in self.initializable_classes:
            # All classes should be initializable, so just try to
            # create each monster
            _ = InitializableClass()

'''

all_monster_classes = []

def format_description(text):
    """Returns a string with the right indentation and formation for an
    attack description.

    """
    paragraphs = text.split("\n")
    paragraphs = ["\n  ".join(textwrap.wrap(par)) for par in paragraphs]
    return "\n      \n  ".join(paragraphs)

def get_spells(monster_data):
    """Returns a string list of spells the monster can cast."""
    spells = []
    for ability in monster_data.get("special_abilities", []):
        if ability['name'] == "Spellcasting":
            spells = ['"%s"' % spell["name"].lower() for spell in ability["spellcasting"]["spells"]]
    return "[" + ", ".join(spells) + "]"

def get_attacks(monster_data):
    """
    Returns a string list of attacks for the monster

    :param monster_data:
    :return:
    """
    outstr = ""
    things = []
    for ability in monster_data.get("special_abilities", []):
        things.append(ability["name"] + ".\n  " + format_description(ability["desc"]))
    for attack in monster_data.get("actions", []):
        things.append(attack["name"] + ".\n  " + format_description(attack["desc"]))
    if things:
        outstr = "" + "\n".join(things)
    return textwrap.indent(outstr, "    ")

def get_skills(monster_data):
    """
    Returns a string list of skills for the monster

    :param monster_data:
    :return:
    """
    # TODO: Also save saving throws
    outstr = ""
    profs = []
    for proficiency in monster_data.get("proficiencies", []):
        if "skill" in proficiency['proficiency']['index']:
            value = proficiency["value"]
            name = proficiency['proficiency']["index"].split("skill-")[1].capitalize()
            prof = f"{name} +{value}"
            profs.append(prof)
    if len(profs) > 0:
        outstr = ", ".join(profs)
    return outstr
    # TODO: Write me!

def get_senses(monster_data):
    """
    Returns a string list of senses for the monster

    :param monster_data:
    :return:
    """
    if not monster_data.get("senses"):
        return ""

    senses = []
    for sense, val in monster_data.get("senses", []).items():
        sense_word = " ".join([word.capitalize() for word in sense.split("_")])
        if type(val) == int:
            sense_val = f"{val}"
        else:
            sense_val = val
        # sense_val = f"+ {val}" if ((type(val) != int) or ("ft" not in val)) else val
        senses.append(sense_word + " " + sense_val)
    return ", ".join(senses)
    # TODO: Write me!

def get_monster_string(monster_data):
    data = monster_data
    data["classname"] = "".join(monster_data["name"].split())
    replacements = [",", "/", "(", ")", "-", "'"]
    for r in replacements:
        data["classname"] = data["classname"].replace(r, "")
    all_monster_classes.append(data["classname"])
    data["description"] = get_attacks(monster_data)
    data["skills"] = get_skills(monster_data)
    data["speed_walk"] = (monster_data["speed"].get("walk", "0").split()[0])
    data["speed_swim"] = (monster_data["speed"].get("swim", "0").split()[0])
    data["speed_fly"] = (monster_data["speed"].get("fly", "0").split()[0])
    data["speed_climb"] = (monster_data["speed"].get("climb", "0").split()[0])
    data["senses"] = get_senses(monster_data)
    data["spells"] = get_spells(monster_data)
    ret = (individual_class.format(**data))
    return ret

def write_monsters():
    with shelve.open(inf, 'r') as db:
        outstr = header
        for monster in db["data"]:
            monster_string = get_monster_string(monster)
            outstr += monster_string
    with open(outf, 'w') as f:
        f.write(outstr)

def write_monsters_test():
    if not all_monster_classes:
        raise ValueError("Must first run write_monsters to get the classes")
    initializable_classes = ",\n        ".join([f"monsters.{this_class}" for this_class in all_monster_classes])
    outstr = unittest_template.format(initializable_classes=initializable_classes)
    with open(outf_unittest, 'w') as f:
        f.write(outstr)

if __name__ == '__main__':
    write_monsters()
    write_monsters_test()
