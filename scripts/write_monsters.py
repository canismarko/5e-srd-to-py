import os
import re
import math
from pathlib import Path
import shelve
import textwrap
import ast
import astunparse


inf = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "local_data", "monsters.shlf")
outf = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "output_files", "monsters.py")
outf_unittest = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")), "output_files", "test_monsters.py")

header = """\"\"\"
monsters.py

A collection of monsters from D&D 5e's SRD

Part of this file was autogenerated by https://github.com/stravajiaxen/5e-srd-to-py
\"\"\"

class Monster:
    pass
    
class Ability:
    
    def __init__(self, num):
        pass

"""

individual_class = \
'''

class {classname}(Monster):
    """
{description}
    """
    name = "{name}"
    description = "{size} {type}, {alignment}"
    challenge_rating = {challenge_rating}
    armor_class = {armor_class}
    skills = "{skills}"
    senses = "{senses}"
    languages = "{languages}"
    strength = Ability({strength})
    dexterity = Ability({dexterity})
    constitution = Ability({constitution})
    intelligence = Ability({intelligence})
    wisdom = Ability({wisdom})
    charisma = Ability({charisma})
    speed = {speed_walk}
    swim_speed = {speed_swim}
    fly_speed = {speed_fly}
    climb_speed = {speed_climb}
    burrow_speed = {speed_burrow}
    hp_max = {hit_points}
    hit_dice = "{hit_dice}"
    condition_immunities = "{condition_immunities}"
    damage_immunities = "{damage_immunities}"
    damage_resistances = "{damage_resistances}"
    damage_vulnerabilities = "{damage_vulnerabilities}"
    spells = {spells}
'''

unittest_template = \
'''from unittest import TestCase

from dungeonsheets import monsters


class AutoGeneratedMonsters(TestCase):

    initializable_classes = [
        {initializable_classes}
    ]
    
    def test_createable(self):
        for InitializableClass in self.initializable_classes:
            # All classes should be initializable, so just try to
            # create each monster
            _ = InitializableClass()

'''

all_monster_classes = []


def format_description(text, is_spellcasting=False):
    """Returns a string with the right indentation and formation for an
    attack description.

    """
    if is_spellcasting:
        new_text = text
    else:
        paragraphs = text.split("\n")
        paragraphs = ["\n  ".join(textwrap.wrap(par)) for par in paragraphs]
        new_text = "\n      \n  ".join(paragraphs)
    return new_text


def get_spells(monster_data):
    """Returns a string list of spells the monster can cast."""
    spells = []
    for ability in monster_data.get("special_abilities", []):
        if ability['name'] == "Spellcasting":
            spells = ['"%s"' % spell["name"].lower() for spell in ability["spellcasting"]["spells"]]
    return "[" + ", ".join(spells) + "]"


def get_attacks(monster_data):
    """
    Returns a string list of attacks for the monster

    :param monster_data:
    :return:
    """
    outstr = ""
    things = []
    categories = {
        "special_abilities": "",
        "actions": "Actions",
        "reactions": "Reactions",
        "legendary_actions": "Legendary Actions",
    }
    for key, title in categories.items():
        abilities = monster_data.get(key, [])
        if len(abilities) > 0:
            if title:
                things.append("\n# {}\n".format(title))
            else:
                things.append("")
        for ability in abilities:
            name = ability["name"]
            desc = format_description(ability["desc"], is_spellcasting=(name.lower() == "spellcasting"))
            things.append("{}.\n  {}".format(ability["name"], desc))
    # for ability in monster_data.get("special_abilities", []):
    #     things.append(ability["name"] + ".\n  " + format_description(ability["desc"]))
    # for attack in monster_data.get("actions", []):
    #     things.append(attack["name"] + ".\n  " + format_description(attack["desc"]))
    if things:
        outstr = "" + "\n".join(things)
    return textwrap.indent(outstr, "    ")


def get_skills(monster_data):
    """
    Returns a string list of skills for the monster

    :param monster_data:
    :return:
    """
    # TODO: Also save saving throws
    outstr = ""
    profs = []
    for proficiency in monster_data.get("proficiencies", []):
        if "skill" in proficiency['proficiency']['index']:
            value = proficiency["value"]
            name = proficiency['proficiency']["index"].split("skill-")[1].capitalize()
            prof = f"{name} +{value}"
            profs.append(prof)
    if len(profs) > 0:
        outstr = ", ".join(profs)
    return outstr
    # TODO: Write me!


def get_senses(monster_data):
    """
    Returns a string list of senses for the monster

    :param monster_data:
    :return:
    """
    if not monster_data.get("senses"):
        return ""

    senses = []
    for sense, val in monster_data.get("senses", []).items():
        sense_word = " ".join([word.capitalize() for word in sense.split("_")])
        if type(val) == int:
            sense_val = f"{val}"
        else:
            sense_val = val
        # sense_val = f"+ {val}" if ((type(val) != int) or ("ft" not in val)) else val
        senses.append(sense_word + " " + sense_val)
    return ", ".join(senses)


def get_condition_immunities(monster_data) -> str:
    """Returns a string list of conditions to which the monster is
    immune.

    """
    return ", ".join([imm['index'] for imm in monster_data['condition_immunities']])


def get_damage_resistances(monster_data) -> str:
    """Returns a string list of damage types to which the monster is
    resistant.

    """
    try:
        damage_resistances = monster_data["damage_resistances"][0]
    except (KeyError, IndexError):
        damage_resistances = ""
    return damage_resistances


def get_damage_immunities(monster_data) -> str:
    """Returns a string list of damage types to which the monster is
    immune.

    """
    return ", ".join(monster_data["damage_immunities"])


def get_damage_vulnerabities(monster_data) -> str:
    """Returns a string list of damage types to which the monster is
    vulnerable.

    """
    return ", ".join(monster_data["damage_vulnerabilities"])


def get_hit_dice(monster_data) -> str:
    """Fixes the missing extra HP in the API's hit_dice property."""
    # Parse the hit dice string
    num, sides = monster_data['hit_dice'].split('d')
    num = int(num)
    sides = int(sides)
    # Predict the total hit points without the bonus
    avg_roll = sides / 2 + 0.5
    subtotal = int(avg_roll * num)
    # Determine the bonus
    bonus = int(monster_data['hit_points']) - subtotal
    # Combine into the proper hit dice string
    hit_dice = "{}d{} + {}".format(num, sides, bonus)
    return hit_dice


def monster_classname(name):
    classname = "".join(name.split())
    replacements = [",", "/", "(", ")", "-", "'"]
    for r in replacements:
        classname = classname.replace(r, "")
    return classname


def get_monster_string(monster_data):
    data = monster_data.copy()
    data["classname"] = monster_classname(data["name"])
    all_monster_classes.append(data["classname"])
    # if data["classname"] == "FireElemental":
    #     import pdb; pdb.set_trace()
    data["condition_immunities"] = get_condition_immunities(monster_data)
    data["damage_immunities"] = get_damage_immunities(monster_data)
    data["damage_resistances"] = get_damage_resistances(monster_data)
    data["damage_vulnerabilities"] = get_damage_vulnerabities(monster_data)
    data["description"] = get_attacks(monster_data)
    data["skills"] = get_skills(monster_data)
    data["speed_walk"] = (monster_data["speed"].get("walk", "0").split()[0])
    data["speed_swim"] = (monster_data["speed"].get("swim", "0").split()[0])
    data["speed_fly"] = (monster_data["speed"].get("fly", "0").split()[0])
    data["speed_climb"] = (monster_data["speed"].get("climb", "0").split()[0])
    data["speed_burrow"] = (monster_data["speed"].get("burrow", "0").split()[0])
    data["senses"] = get_senses(monster_data)
    data["spells"] = get_spells(monster_data)
    data["hit_dice"] = get_hit_dice(monster_data)
    ret = (individual_class.format(**data))
    return ret


def get_existing_ast():

    """Load some existing monster definitions as an Abstract Syntax Tree"""
    extra_dir = Path('~/src/dungeon-sheets/dungeonsheets/monsters').expanduser()
    extra_files = [extra_dir / f"monsters_{l}.py" for l in ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')]
    # Open each file and load the AST
    monsters = {}
    for path in extra_files:
        with open(path, mode='r') as fp:
            tree = ast.parse(fp.read())
            for item in tree.body:
                if isinstance(item, ast.ClassDef):
                    monsters[item.name] = item
    return monsters


def unparse_monster_ast(monster_ast):
    # Handle the docstring
    docstring = monster_ast.body[0].value.s
    pycode = astunparse.unparse(monster_ast)
    # Fix the docstring
    pycode = re.sub('^    "(.*)"$',
                    r'    """\1"""',
                    pycode, flags=re.M)
    pycode = re.sub("^    '(.*)'$",
                    r'    """\1"""',
                    pycode, flags=re.M)
    pycode = pycode.replace(r'\n', '\n')
    return pycode


def write_monsters():
    # Load existing monsters as an AST
    monsters_ast = get_existing_ast()
    # Create new monsters as AST and overwrite existing class defs
    with shelve.open(inf, 'r') as db:
        outstr = header
        for monster in db["data"]:
            monster_string = get_monster_string(monster)
            monster_ast = ast.parse(monster_string).body[0]
            classname = monster_classname(monster["name"])
            monsters_ast[classname] = monster_ast
    with open(outf, 'w') as f:
        f.write(header)
        f.write("\n\n")
        # Convert AST's back into python code
        for classname, monster_ast in sorted(monsters_ast.items()):
            f.write(unparse_monster_ast(monster_ast))


def write_monsters_test():
    if not all_monster_classes:
        raise ValueError("Must first run write_monsters to get the classes")
    initializable_classes = ",\n        ".join([f"monsters.{this_class}" for this_class in all_monster_classes])
    outstr = unittest_template.format(initializable_classes=initializable_classes)
    with open(outf_unittest, 'w') as f:
        f.write(outstr)


if __name__ == '__main__':
    write_monsters()
    write_monsters_test()
